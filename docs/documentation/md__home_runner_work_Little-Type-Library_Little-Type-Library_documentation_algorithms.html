<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Little Type Library: Algorithms library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Little Type Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_Little-Type-Library_Little-Type-Library_documentation_algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Algorithms library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here we are going to discuss about standard algorithms and what <b>LTL</b> can bring to them.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Predicates</h1>
<p>Let's say we have a list of numbers and we want to check if there is one that is less than 8 Thanks <code>std::any_of</code>algorithm, we can write something close to : </p><div class="fragment"><div class="line">std::array <a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a> = {0, 1, 2, 6, 9, 8, 14, 58, 65};</div>
<div class="line"><span class="keywordtype">bool</span> result = std::any_of(begin(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), end(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), [](<span class="keywordtype">int</span> x) {<span class="keywordflow">return</span> x &lt; 8;});</div>
</div><!-- fragment --><p>Now, say we want to know if there is a number that is less than 8 or greater than 18</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> result = std::any_of(begin(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), end(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), [](<span class="keywordtype">int</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> (x &lt; 8) || (x &gt; 18);</div>
<div class="line">});</div>
</div><!-- fragment --><p>It is all easy but there is a lot of boiler plate...</p>
<p><b>LTL</b> provides some predicates and some helper function to deal with such problems:</p><ul>
<li><code>less_than(x)</code></li>
<li><code>less_than_equal(x)</code></li>
<li><code>equal_to(x)</code></li>
<li><code>greater_than(x)</code></li>
<li><code>greater_than_equal(x)</code></li>
<li><code>not_equal_to(x)</code></li>
<li><code>and_(predicates...)</code></li>
<li><code>or_(predicates...)</code></li>
<li><code>not_(f)</code></li>
<li><code>byAscending(f)</code></li>
<li><code>byDescending(f)</code></li>
<li><code>compose(fs)</code>: It is the reverse composition : <code>compose(f, g)(x) = g(f(x))</code></li>
</ul>
<p>Knowing that the examples above can be written as following </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> result1 = std::any_of(begin(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), end(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), <a class="code" href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">less_than</a>(8));</div>
<div class="line"><span class="keywordtype">bool</span> result2 = std::any_of(begin(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), end(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>), <a class="code" href="group__Predicate.html#gac54a6d109e299f7e10f82ecb6b5d4fdf">or_</a>(<a class="code" href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">less_than</a>(8), <a class="code" href="group__Predicate.html#ga1bec6461e75fd6837e595165a6e7672c">greater_than</a>(18)));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Removing the need of iterators</h1>
<p><b>LTL</b> provides all algorithms without the need to use iterators. The code above could be written as: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> result1 = ltl::any_of(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>, <a class="code" href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">less_than</a>(8));</div>
<div class="line"><span class="keywordtype">bool</span> result2 = ltl::any_of(<a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>, <a class="code" href="group__Predicate.html#gac54a6d109e299f7e10f82ecb6b5d4fdf">or_</a>(<a class="code" href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">less_than</a>(8), <a class="code" href="group__Predicate.html#ga1bec6461e75fd6837e595165a6e7672c">greater_than</a>(18)));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Using pointer to member function of pointer to member attributes</h1>
<p>Let's say we have the <b>Bottle</b> type : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Bottle {</div>
<div class="line">  <span class="keywordtype">bool</span> isEmpty;</div>
<div class="line">};</div>
</div><!-- fragment --><p>We want to know if there is one empty bottle in our collections, we can use a pointer to the member attributes</p>
<div class="fragment"><div class="line">std::vector&lt;Bottle&gt; bottles;</div>
<div class="line"><span class="keywordtype">bool</span> result = ltl::any_of(bottles, &amp;Bottle::isEmpty);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Find functions</h1>
<p>C++17 brought us <code>std::optional</code>which is an equivalent to the <code>Option</code> monad in functional languages. The standard <code>find</code>(and <code>find_if</code>...) algorithm returns an iterator. The iterator is valid if the algorithm found the value, and is equals to the end of the container if the algorithm does not. It makes mandatory to write such things : </p><div class="fragment"><div class="line">std::vector&lt;Bottle&gt; bottles;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> itEmptyBottle = ltl::find_if(bottles, &amp;Bottle::isEmpty);</div>
<div class="line">   itEmptyBottle != end(bottles)) {</div>
<div class="line">    fillBottle(*itEmptyBottle);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>LTL</b> provides <code>find_value</code>, <code>find_ptr</code> (also for <code>find_if</code> and <code>find_if_not</code>). The function with <code>_value</code>suffixes returns a <code>std::optional&lt;T&gt;</code> (here a <code>std::optional&lt;Bottle&gt;</code>) and the function with <code>_ptr</code>returns a pointer<code>T*</code>.</p>
<p>It allows us to write </p><div class="fragment"><div class="line">std::vector&lt;Bottle&gt; bottles;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> emptyBottle = ltl::find_if_value(bottles, &amp;Bottle::isEmpty)) {</div>
<div class="line">    display(*emptyBottle); <span class="comment">// It is useless to modify emptyBottle since it is a copy</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> *emptyBottle = ltl::find_if_ptr(bottles, &amp;Bottle::isEmpty)) {</div>
<div class="line">    fill(*emptyBottle);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Zip</h1>
<p>Sometimes, it happens that we have two correlated collections </p><div class="fragment"><div class="line">std::vector&lt;int&gt; v1;</div>
<div class="line">std::vector&lt;int&gt; v2;</div>
<div class="line"> </div>
<div class="line">assert(v1.size() == v2.size());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; v1.size(); ++i) {</div>
<div class="line">    use(v1[i], v2[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>LTL</b> provides a <code>zip</code>function that make things easier</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v1;</div>
<div class="line">std::vector&lt;int&gt; v2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [a, b] : <a class="code" href="group__Iterator.html#gaa9a8eb5e6a506100aff4a16152809753">ltl::zip</a>(v1, v2)) {</div>
<div class="line">    use(a, b);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><a class="code" href="group__Tuple.html#ga935bc5c84e3755e29a473d74e73cdb5f">ltl::for_each</a>(<a class="code" href="group__Iterator.html#gaa9a8eb5e6a506100aff4a16152809753">ltl::zip</a>(v1, v2), <a class="code" href="group__Function.html#ga6b3e862ba5f3700a0803680a05942307">ltl::unzip</a>(use));</div>
</div><!-- fragment --><p><code>unzip</code> is a function that takes a function as argument and returns a callable that takes something <em>applyable</em> like a <code>std::pair</code>, <code>std::tuple</code> or a <code><a class="el" href="structltl_1_1tuple__t.html" title="tuple_t - Fast compiling tuple">ltl::tuple_t</a></code> and forward it to the function given to <code>unzip</code></p>
<p>For Python lovers, we provide also <code>enumerate</code></p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [index, value] : <a class="code" href="group__Iterator.html#gaf8fcf65dc0f6ed645037c813b0a42c28">enumerate</a>(array)) {</div>
<div class="line">    use(index, value);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Index</h1>
<p>It can happen that we need to find the index of an element when we are dealing with containers. In C++, we often saw such a code : </p><div class="fragment"><div class="line">std::vector&lt;int&gt; array;</div>
<div class="line"><span class="keyword">auto</span> result = -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0u; i &lt; array.size(); ++i) {</div>
<div class="line">   <span class="keywordflow">if</span>(array[i] == 18) {</div>
<div class="line">       result = i;</div>
<div class="line">       <span class="keywordflow">break</span>;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(result != -1)</div>
<div class="line">    use(array[result]);</div>
<div class="line">    </div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> it = ltl::find(array, 18);</div>
<div class="line"><span class="keyword">auto</span> result = std::distance(begin(array), it);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(result != array.size())</div>
<div class="line">    use(array[result]);</div>
</div><!-- fragment --><p>It is a lot of boilerplate. As such, <b>LTL</b> provides <code>index_of</code> and <code>index_if</code> functions that returns an <code>std::optional&lt;std::size_t&gt;</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x){<span class="keywordflow">return</span> x % 2 == 1;};</div>
<div class="line">std::vector array = {0, 1, 2, 3, 4, 5, 6, 7};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> index = ltl::index_of(array, 6)) {</div>
<div class="line">    use(*index);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> index = ltl::index_if(array, is_odd)) {</div>
<div class="line">    use(*index);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__Predicate_html_ga5857312341913c48e744c1629662dea3"><div class="ttname"><a href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">ltl::less_than</a></div><div class="ttdeci">constexpr auto less_than(T t)</div><div class="ttdoc">less_than- This function builds a predicate testing if a value is less than t</div><div class="ttdef"><b>Definition:</b> functional.h:390</div></div>
<div class="ttc" id="agroup__Function_html_ga6b3e862ba5f3700a0803680a05942307"><div class="ttname"><a href="group__Function.html#ga6b3e862ba5f3700a0803680a05942307">ltl::unzip</a></div><div class="ttdeci">constexpr auto unzip(F f)</div><div class="ttdoc">unzip - It is the opposite of zip. It will feed f with all elements of the tuple</div><div class="ttdef"><b>Definition:</b> functional.h:136</div></div>
<div class="ttc" id="agroup__Iterator_html_gaa9a8eb5e6a506100aff4a16152809753"><div class="ttname"><a href="group__Iterator.html#gaa9a8eb5e6a506100aff4a16152809753">ltl::zip</a></div><div class="ttdeci">auto zip(Containers &amp;&amp;...containers)</div><div class="ttdoc">zip - Allows to iterate on several containers at the same time</div><div class="ttdef"><b>Definition:</b> Zip.h:91</div></div>
<div class="ttc" id="agroup__Iterator_html_gaf8fcf65dc0f6ed645037c813b0a42c28"><div class="ttname"><a href="group__Iterator.html#gaf8fcf65dc0f6ed645037c813b0a42c28">ltl::enumerate</a></div><div class="ttdeci">auto enumerate(Container &amp;&amp;container)</div><div class="ttdoc">enumerate - enumerate elements with a tuple of index, element</div><div class="ttdef"><b>Definition:</b> enumerate.h:30</div></div>
<div class="ttc" id="agroup__Predicate_html_gac54a6d109e299f7e10f82ecb6b5d4fdf"><div class="ttname"><a href="group__Predicate.html#gac54a6d109e299f7e10f82ecb6b5d4fdf">ltl::or_</a></div><div class="ttdeci">constexpr auto or_(Fs... fs)</div><div class="ttdoc">This function transforms a list of predicates into fs[0] || fs[1] || ...</div><div class="ttdef"><b>Definition:</b> functional.h:253</div></div>
<div class="ttc" id="agroup__Iterator_html_ga71aaad82623b7b38009d52cde1a31323"><div class="ttname"><a href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">ltl::values</a></div><div class="ttdeci">auto values()</div><div class="ttdoc">keys - may be used to iterate on the values of one map</div><div class="ttdef"><b>Definition:</b> DefaultView.h:104</div></div>
<div class="ttc" id="agroup__Predicate_html_ga1bec6461e75fd6837e595165a6e7672c"><div class="ttname"><a href="group__Predicate.html#ga1bec6461e75fd6837e595165a6e7672c">ltl::greater_than</a></div><div class="ttdeci">constexpr auto greater_than(T t)</div><div class="ttdoc">greater_than- This function builds a predicate testing if a value is greater than t</div><div class="ttdef"><b>Definition:</b> functional.h:420</div></div>
<div class="ttc" id="agroup__Tuple_html_ga935bc5c84e3755e29a473d74e73cdb5f"><div class="ttname"><a href="group__Tuple.html#ga935bc5c84e3755e29a473d74e73cdb5f">ltl::for_each</a></div><div class="ttdeci">F for_each(Tuple &amp;&amp;tuple, F &amp;&amp;f)</div><div class="ttdoc">for_each - call f on each member of the tuple</div><div class="ttdef"><b>Definition:</b> Tuple.h:427</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
