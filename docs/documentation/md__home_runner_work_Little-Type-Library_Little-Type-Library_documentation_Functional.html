<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Little Type Library: Functional library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Little Type Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_Little-Type-Library_Little-Type-Library_documentation_Functional.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Functional library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>It is one of the core library of <b>LTL</b>. The idea is to try to write code in a functional style keeping high performances and expressiveness. </p>
<h1><a class="anchor" id="autotoc_md8"></a>
Pipelining operations</h1>
<p>Standard algorithms are cool. They are fast, easy to use, expressive, customisable and everything we want. However, they are not easily composable Given an array of integers, how to sum the square of the odd values, by using algorithms?</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceltl.html">ltl</a>;</div>
<div class="line">std::vector array = {0, 1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x){<span class="keywordflow">return</span> x % 2 == 1;};</div>
<div class="line"><span class="keyword">auto</span> square = [](<span class="keyword">auto</span> x){<span class="keywordflow">return</span> x * x;};</div>
<div class="line">array.erase(remove_if(array, <a class="code" href="group__Predicate.html#ga777694a4b96b1e382d095982de34a8e1">not_</a>(is_odd)), end(array));</div>
<div class="line">transform(array, begin(array), square);</div>
<div class="line"><span class="keyword">auto</span> result = accumulate(array, 0);</div>
</div><!-- fragment --><p>In shell, we could do something close to</p>
<div class="fragment"><div class="line">commandThatReturnIntList | onlyOdd | square | sum</div>
</div><!-- fragment --><p>The C++ solution using <b>LTL</b> is: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = array | <a class="code" href="group__Iterator.html#gacee10337f816c2e99d0fe47c681e95ee">filter</a>(is_odd) | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square) | accumulate(0);</div>
</div><!-- fragment --><p>Here, the <code>|</code> notation works also with rvalue reference. C++20 range does not.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Proxy iterators</h2>
<p>Proxy iterators are an abstraction over iterators. They can iterate only on specific values (filtering), or they can transform the underlying value (mapping). <b>LTL</b> provides a lot of different proxy iterators. </p>
<h3><a class="anchor" id="autotoc_md10"></a>
map iterator</h3>
<p>Mapping operation allows us to apply a function over each element of the list. Map iterator are given by the following C++ function</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(Fs...) noexcept;</div>
</div><!-- fragment --><p><code>Fs</code> are composed. Let's say we want to apply twice the <code>square</code> function</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> elem : array | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square, square)) {</div>
<div class="line">    use(elem);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> elem : array | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square) | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square)) {</div>
<div class="line">    use(elem);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>LTL</b> provides also <code>transform</code> that is just an alias to <code>map</code></p>
<h3><a class="anchor" id="autotoc_md11"></a>
filter iterator</h3>
<p>Filtering operation allows us to iterate over a subset of elements which satify a predicate. Filter iterator are given by the following C++ function </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Fs&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="group__Iterator.html#gacee10337f816c2e99d0fe47c681e95ee">filter</a>(Fs...) noexcept;</div>
</div><!-- fragment --><p><code>Fs</code> are composed and must give out a boolean value. Let's say we want to iterate over the square values that are less than 10.</p>
<div class="fragment"><div class="line">std::array array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> elem : array | <a class="code" href="group__Iterator.html#gacee10337f816c2e99d0fe47c681e95ee">filter</a>(square, <a class="code" href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">less_than</a>(10))) {</div>
<div class="line">    use(elem);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> elem : array | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square) | <a class="code" href="group__Iterator.html#gacee10337f816c2e99d0fe47c681e95ee">filter</a>(<a class="code" href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">less_than</a>)) {</div>
<div class="line">    use(elem);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>LTL</b> provides also <code>remove_if</code>.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
taker</h3>
<p>It can happen that we want to take the 10 first values of a container, or remove the 5 first. <b>LTL</b> provides <code>take_n</code> and <code>drop_n</code> for such operation</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> view = array | <a class="code" href="group__Iterator.html#ga87828246d210b7f31c7fd30ca22fd84f">drop_n</a>(5) | take(10); <span class="comment">// take the sixth to the fiftennth element</span></div>
</div><!-- fragment --><p>You can also use <code>drop_while</code> or <code>take_while</code>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
split</h3>
<p>Let's have a string: </p><div class="fragment"><div class="line">std::string <span class="keywordtype">string</span> = <span class="stringliteral">&quot;Using LTL is great&quot;</span>;</div>
</div><!-- fragment --><p>We want to split it by spaces. </p><div class="fragment"><div class="line">[&quot;Using&quot;, &quot;LTL&quot;, &quot;is&quot;, &quot;great&quot;]</div>
</div><!-- fragment --><p><code>SplitIterator</code> returns something like <code>Range&lt;It&gt;</code> when we dereference it, so, we want to transform this range to a <code>std::string_view</code>. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> to_view = [](<span class="keyword">auto</span> &amp;&amp;r) {<span class="keywordflow">return</span> std::string_view{&amp;*r.begin(), r.size()};};</div>
<div class="line"><span class="keyword">auto</span> splitted = <span class="keywordtype">string</span> | <a class="code" href="group__Iterator.html#ga7b03e216561ecbfb53d050fe3c9960bc">split</a>(<span class="charliteral">&#39; &#39;</span>) | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(to_view);</div>
<div class="line"><span class="comment">// splitted = [&quot;Using&quot;, &quot;LTL&quot;, &quot;is&quot;, &quot;great&quot;]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
group_by</h3>
<p>Let's say you have a Player </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Player {</div>
<div class="line">    Team team;</div>
<div class="line">    std::string name;</div>
<div class="line">};</div>
</div><!-- fragment --><p>You have a collection of Players sorted by teams. You want to iterate over each teams without copying anything or build a map. <b>LTL</b> provides <code>group_by</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;Player&gt; all_players;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [team, players] : all_players | <a class="code" href="group__Iterator.html#ga54ef4e52db5c3f101bf95a9cdef15892">group_by</a>(&amp;Player::team)) {</div>
<div class="line">    std::cout &lt;&lt; team.name &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;player : players) {</div>
<div class="line">        std::cout &lt;&lt; player.name &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
chunks</h3>
<p>Chunks are good for you if you want to have views without more than <code>n</code> elements.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>(1000);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> views : <a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>(1000) | <a class="code" href="group__Iterator.html#gaa6c8a1e5de898576082f39b3b81b180a">chunks</a>(100)) {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> item : views) { <span class="comment">// each views has 100 items</span></div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
reverse</h3>
<p>With <code>reversed</code> you can iterate over your arrays or your views in reversed way. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> to_view = [](<span class="keyword">auto</span> &amp;&amp;r) {<span class="keywordflow">return</span> std::string_view{&amp;*r.begin(), r.size()};};</div>
<div class="line"><span class="keyword">auto</span> splitted = <span class="keywordtype">string</span> | <a class="code" href="group__Iterator.html#ga7b03e216561ecbfb53d050fe3c9960bc">split</a>(<span class="charliteral">&#39; &#39;</span>) | <a class="code" href="group__Iterator.html#gacedb09b08c951309da418b9912d69c32">reversed</a> | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(to_view);</div>
<div class="line"><span class="comment">// splitted = [&quot;great&quot;, &quot;is&quot;, &quot;LTL&quot;, &quot;Using&quot;]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md17"></a>
dereference</h3>
<p>If you have an array of smart pointers, like <code>std::unique_ptr</code>, or an array of <code>std::optional</code> you will not be able to map directly over a member function. One way to address this problem could be to use the <b>LTL</b>'s <code>dereference</code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Person&gt; persons;</div>
<div class="line"><span class="keyword">auto</span> names = persons | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(<a class="code" href="group__Iterator.html#gaa4146439d375f3a350a47a035ec247ed">dereference</a>, &amp;Person::name);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keyword">auto</span> names = persons | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(<a class="code" href="group__Iterator.html#gaa4146439d375f3a350a47a035ec247ed">dereference</a>) | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(Person::name);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
values, keys, get</h3>
<p>These helpers are useful for <em>tuple</em> based container, like <code>std::map</code>, <code>std::vector&lt;std::pair&lt;std::string, int&gt;&gt;</code> or <code>std::vector&lt;tuple_t&lt;int, double, std::string&gt;&gt;</code>.</p>
<div class="fragment"><div class="line">std::map&lt;std::string, int&gt; <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [key, value] : <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>) {</div>
<div class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> key : <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a> | <a class="code" href="group__Iterator.html#gaffb03e23417a57a9def326dee22b4ab2">keys</a>()) {</div>
<div class="line">    std::cout &lt;&lt; key &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> value : <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a> | <a class="code" href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">values</a>()) {</div>
<div class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;tuple_t&lt;int, double, std::string&gt;&gt; vector;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [i, d, str] : vector) {}</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [i, str] : vector | <a class="code" href="group__Iterator.html#ga822354d10fc9425934c42b624ee8b4f8">get</a>(0_n, 2_n)) {}</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [d, str, i] : vector | <a class="code" href="group__Iterator.html#ga822354d10fc9425934c42b624ee8b4f8">get</a>(1_n, 2_n, 0_n)) {}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Transforming to a normal container</h3>
<p>Sometimes, it can happen that you need to retrieve the result inside a standard container, or simply return the result of an operation. There is two ways to convert a <code>Range</code> into a standard container</p><ol type="1">
<li>Use the fact that container have a constructor like <code>container(It begin, It end)</code> (It is the recommanded way)</li>
<li>Use the <code>to_vector</code>, <code>to_list</code> and <code>to_queue</code></li>
</ol>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vector1 = {0, 1, 2, 3, 4, 5, 6};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// here vector2 = vector3 = [0, 2, 4, 6, 8, 10, 12]</span></div>
<div class="line">std::vector&lt;int&gt; vector2 = vector1 | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>([](<span class="keyword">auto</span> x){<span class="keywordflow">return</span> x * 2;});</div>
<div class="line"><span class="keyword">auto</span> vector3 = vector1 | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>([](<span class="keyword">auto</span> x){<span class="keywordflow">return</span> x * 2;}) | to_vector;</div>
</div><!-- fragment --><p>If you want to construct a <code>map</code> from two <code>vector</code>, you can use the fact that map wait for iterators of pair </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; strings;</div>
<div class="line">std::vector&lt;int&gt; <a class="code" href="group__Iterator.html#ga3ac37c2fa552273ee2d947f2930bb02d">ints</a>;</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, int&gt; <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a> = <a class="code" href="group__Iterator.html#gaa9a8eb5e6a506100aff4a16152809753">zip</a>(strings, <a class="code" href="group__Iterator.html#ga3ac37c2fa552273ee2d947f2930bb02d">ints</a>) | <a class="code" href="group__Iterator.html#gab9354e42fded1cf717685d179f83dc68">to_pair</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Infinite sequences</h2>
<p>Let's say you want to have an infinite sequence fed by a nullary callable. You can use the <code>seq</code> function to transform your function into a kind of generator and apply operation on it through the <code>|</code> operator.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> generator = [i = 0]() <span class="keyword">mutable</span> { <span class="keywordflow">return</span>  i++; };</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i : <a class="code" href="group__Iterator.html#gade507d0b203461224cc0cdb92a6e1467">seq</a>(generator) | <a class="code" href="group__Iterator.html#ga37704dc3acaccee28755709ef75ed354">take_n</a>(5)) {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You can also use the <code>end_seq</code> function to stop a sequence :</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> generator = [i = 0]() <span class="keyword">mutable</span> {</div>
<div class="line">    <span class="keywordflow">if</span>(i == 5)</div>
<div class="line">        <a class="code" href="group__Iterator.html#ga0d78422df13a2d341e25918c79f81be3">end_seq</a>();</div>
<div class="line">    <span class="keywordflow">return</span> i++;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i : <a class="code" href="group__Iterator.html#gade507d0b203461224cc0cdb92a6e1467">seq</a>(generator)) {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">//0 1 2 3 4</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Actions</h2>
<p>Actions are a beautiful way to compose modifying algorithms, or to reduce a range to one value (like a find, or fold left)</p>
<p>There is currently 4 kinds of actions that modify a container:</p><ol type="1">
<li>sort</li>
<li>sort_by</li>
<li>unique</li>
<li>reverse</li>
</ol>
<div class="fragment"><div class="line">std::vector&lt;int&gt; anArrayOfInt;</div>
<div class="line">anArrayOfInt |= <a class="code" href="group__Actions.html#gad24b3915f4ed26cab9a1d90ad74e7813">actions::sort</a>; <span class="comment">// anArrayOfInt is now sorted</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="group__Iterator.html#gacedb09b08c951309da418b9912d69c32">reversed</a> = anArrayOfInt | <a class="code" href="group__Iterator.html#gacedb09b08c951309da418b9912d69c32">actions::reversed</a>;</div>
<div class="line">anArrayOfInt |= <a class="code" href="group__Actions.html#ga8024db6ac1061ac068776a861060389f">actions::unique</a>; <span class="comment">// There is no duplicate </span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> re_sortedArrayWithoutDuplicate = <a class="code" href="group__Iterator.html#gacedb09b08c951309da418b9912d69c32">reversed</a> | <a class="code" href="group__Actions.html#gad24b3915f4ed26cab9a1d90ad74e7813">actions::sort</a> | <a class="code" href="group__Actions.html#ga8024db6ac1061ac068776a861060389f">actions::unique</a>;</div>
</div><!-- fragment --><p>There is currently 8 non modyfing actions</p><ol type="1">
<li>find</li>
<li>find_value</li>
<li>find_ptr</li>
<li>find_if</li>
<li>find_if_value</li>
<li>find_if_ptr</li>
<li>accumulate</li>
<li>join_with</li>
</ol>
<p>The advantage for the <code>find_if</code> actions over the algorithms is the composability automatics of predicate functions. However, the last function given must give out a <code>bool</code></p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; strings = {<span class="stringliteral">&quot;My&quot;</span>, <span class="stringliteral">&quot;Name&quot;</span>, <span class="stringliteral">&quot;Is&quot;</span>, <span class="stringliteral">&quot;Antoine&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> <span class="keywordtype">string</span> = strings | <a class="code" href="group__Actions.html#ga6ff821f57777c3853c60bc587ce06148">actions::join_with</a>(<span class="charliteral">&#39; &#39;</span>); <span class="comment">// string = &quot;My Name Is Antoine&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">}</div>
<div class="line">std::vector&lt;Person&gt; persons;</div>
<div class="line"><span class="comment">// antoine is an std::optional&lt;Person&gt;</span></div>
<div class="line"><span class="keyword">auto</span> antoine = persons | actions::find_if(&amp;Person::name, <a class="code" href="group__Predicate.html#gac38720fc28032cf85803d4860c42cd09">equal_to</a>(<span class="stringliteral">&quot;Antoine&quot;</span>));</div>
<div class="line"> </div>
<div class="line">std::vector <a class="code" href="group__Iterator.html#ga3ac37c2fa552273ee2d947f2930bb02d">ints</a> = {0, 1, 2, 3, 4, 5}</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code" href="group__Iterator.html#ga3ac37c2fa552273ee2d947f2930bb02d">ints</a> | actions::accumulate(0); <span class="comment">// 0 + 0 + 1 + 2 + 3 + 4 + 5</span></div>
</div><!-- fragment --><p>You can create stateless lambda in a simple way with macro <code>_</code>.</p>
<div class="fragment"><div class="line">_((variables), expr)</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="group__Actions.html#ga4df134e001b20a5dd3df25876b227c1c">sum</a> = _((x, y), x + y);</div>
<div class="line"><span class="keyword">auto</span> isOdd = _((x), x % 2 == 1);</div>
<div class="line"><span class="keyword">auto</span> square = _((x), x * x);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md22"></a>
List Monad</h1>
<p>We saw how to pipeline several algorithms. We also saw that array are <em>mappable</em> (i.e, they are functor). Now, imagine you have a function that takes one integer <code>n</code> and returns a list containing <code>n</code> times <code>n</code>.</p>
<div class="fragment"><div class="line">f(0) = []</div>
<div class="line">f(4) = [4, 4, 4, 4]</div>
<div class="line">f(5) = [5, 5, 5, 5, 5];</div>
</div><!-- fragment --><p>To generate this function, you can use <code>make_repeater_range(value, number)</code> from <b>LTL</b>. Now, I want to create an array that contains: </p><div class="fragment"><div class="line">[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6...]</div>
</div><!-- fragment --><p>First try : </p><div class="fragment"><div class="line"><span class="keyword">auto</span> f = [](<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> <a class="code" href="group__Iterator.html#ga79fbf6f82cc0622866f1e704102690d3">make_repeater_range</a>(n, n);};</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code" href="group__Iterator.html#gaaa844a1d26bfc69422ea7c4aad338d22">valueRange</a>(0) | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(f);</div>
</div><!-- fragment --><p>We have the idea, but we get</p>
<div class="fragment"><div class="line">[[1], [2, 2], [3, 3, 3], [4, 4, 4, 4], [5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]...]</div>
</div><!-- fragment --><p>Here is the beauty of monads, we can join the array :</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = [](<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> <a class="code" href="group__Iterator.html#ga79fbf6f82cc0622866f1e704102690d3">make_repeater_range</a>(n, n);};</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code" href="group__Iterator.html#gaaa844a1d26bfc69422ea7c4aad338d22">valueRange</a>(0) | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(f) | <a class="code" href="group__Iterator.html#ga93e03390a20d5d3e15fa03ef6e75f000">join</a>;</div>
</div><!-- fragment --><p>For expression like <code>map(f) | join</code>, you can use the <code>&gt;&gt;</code> operator</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = [](<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> <a class="code" href="group__Iterator.html#ga79fbf6f82cc0622866f1e704102690d3">make_repeater_range</a>(n, n);};</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code" href="group__Iterator.html#gaaa844a1d26bfc69422ea7c4aad338d22">valueRange</a>(0) &gt;&gt; <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(f);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Option Monad</h1>
<p>The option monad in C++ is represented by <code>std::optional</code> The mapping operation is as follow :</p>
<div class="fragment"><div class="line"><a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(optional, f) {</div>
<div class="line">    <span class="keywordflow">if</span>(optional == nullopt)</div>
<div class="line">        <span class="keywordflow">return</span> nullopt;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__Utils.html#ga83843d907297b7a11d1875935371eb16">make_optional</a>(f(*optional)); </div>
<div class="line">}</div>
</div><!-- fragment --><p>(This code does not compile, it is just a kind of pseudo code)</p>
<p>Thanks to the <code>|</code> operator seen in previous chapter, you can write :</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> square = [](<span class="keyword">auto</span> x) {<span class="keywordflow">return</span> x * x;};</div>
<div class="line">std::optional&lt;int&gt; value = 5;</div>
<div class="line">std::optional&lt;int&gt; empty;</div>
<div class="line"><span class="keyword">auto</span> valueSquared = value | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square);</div>
<div class="line"><span class="keyword">auto</span> empty2 = empty | <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(square);</div>
</div><!-- fragment --><p>What happen if <code>f</code> returns an <code>optional</code> too ? You will get a <code>std::optional&lt;std::optional&lt;T&gt;&gt;</code>. To avoid that, you must use the <code>&gt;&gt;</code> operator</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::optional&lt;std::string&gt; address;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::optional&lt;Person&gt; person;</div>
<div class="line"> </div>
<div class="line">std::optional&lt;std::string&gt; address = person &gt;&gt; <a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(&amp;Person::address);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Error Monad</h1>
<p>The error Monad is represented in <b>LTL</b> by the type <code>expected&lt;result_type, error_type&gt;</code>.</p>
<p>The map operation is represented by</p>
<div class="fragment"><div class="line"><a class="code" href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">map</a>(expected, f) {</div>
<div class="line">    <span class="keywordflow">if</span>(expected.is_result()) {</div>
<div class="line">        <span class="keywordflow">return</span> make_expected(f(expected.result()));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> make_expected(expected.error());</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since the <code>expected</code> type is not standard, here is a brief overview :</p>
<div class="fragment"><div class="line"><span class="keyword">struct  </span>value_tag  {};</div>
<div class="line"><span class="keyword">struct  </span>error_tag  {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span>  Result,  <span class="keyword">typename</span>  Err&gt;</div>
<div class="line"><span class="keyword">class  </span>[[nodiscard]]  expected  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span>  value_type  =  Result;</div>
<div class="line">  <span class="keyword">using</span>  error_type  =  Err;</div>
<div class="line"> </div>
<div class="line">  static_assert(!std::is_reference_v&lt;value_type&gt;,  <span class="stringliteral">&quot;value_type  must  not  be  a  reference&quot;</span>);</div>
<div class="line">  static_assert(!std::is_reference_v&lt;error_type&gt;,  <span class="stringliteral">&quot;error_type  must  not  be  a  reference&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  constexpr expected(T &amp;&amp;t);</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  constexpr expected(value_tag, T &amp;&amp;t);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  constexpr expected(error_tag,  T &amp;&amp;t);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>  &lt;<span class="keyword">typename</span>  R,  <span class="keyword">typename</span>  E&gt;</div>
<div class="line">  constexpr expected &amp;operator=(expected&lt;R, E&gt; t);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>  &lt;<span class="keyword">typename</span>  T&gt;</div>
<div class="line">  constexpr  expected  &amp;operator=(T)  =  <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">  constexpr  <span class="keyword">operator</span>  bool()  const  noexcept;</div>
<div class="line"> </div>
<div class="line">  constexpr  value_type  result();</div>
<div class="line">  constexpr  error_type  error();</div>
<div class="line">  constexpr  <span class="keywordtype">bool</span>  is_error()  const;</div>
<div class="line">  constexpr  <span class="keywordtype">bool</span>  is_result()  const;</div>
<div class="line">};</div>
</div><!-- fragment --><p>As for optional, you can use <code>| map(f)</code> to process a result, and <code>&gt;&gt; map(f)</code> when <code>f</code> returns an expected.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Currying</h1>
<p>Currying is used to transform a n-arry function into a "series" of unary function <code>f(x, y, z)=f(x)(y)(z)</code>. You can use <code><a class="el" href="group__Function.html#ga9d966b78854a64163c1abe442260ef3d" title="curry - Currying is done to transform n ary function into unary ones">ltl::curry</a></code>to have such behaviour, it is inside the <code><a class="el" href="functional_8h.html">ltl/functional.h</a></code> header file:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = _((x, y, z), x + y + z);</div>
<div class="line"><span class="keyword">auto</span> curriedF = <a class="code" href="group__Function.html#ga9d966b78854a64163c1abe442260ef3d">ltl::curry</a>(f);</div>
<div class="line">static_assert(f(3, 4, 5) == curriedF(3, 4)(5));</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__Iterator_html_gacee10337f816c2e99d0fe47c681e95ee"><div class="ttname"><a href="group__Iterator.html#gacee10337f816c2e99d0fe47c681e95ee">ltl::filter</a></div><div class="ttdeci">constexpr auto filter(Fs... fs)</div><div class="ttdoc">filter - Used to filter a list of element</div><div class="ttdef"><b>Definition:</b> Filter.h:75</div></div>
<div class="ttc" id="agroup__Iterator_html_gaffb03e23417a57a9def326dee22b4ab2"><div class="ttname"><a href="group__Iterator.html#gaffb03e23417a57a9def326dee22b4ab2">ltl::keys</a></div><div class="ttdeci">auto keys()</div><div class="ttdoc">keys - may be used to iterate on the keys of one map</div><div class="ttdef"><b>Definition:</b> DefaultView.h:92</div></div>
<div class="ttc" id="agroup__Actions_html_ga6ff821f57777c3853c60bc587ce06148"><div class="ttname"><a href="group__Actions.html#ga6ff821f57777c3853c60bc587ce06148">ltl::actions::join_with</a></div><div class="ttdeci">constexpr auto join_with(D &amp;&amp;d)</div><div class="ttdoc">join_with - Join a list with a delimeter : Useful for strings</div><div class="ttdef"><b>Definition:</b> actions.h:352</div></div>
<div class="ttc" id="agroup__Iterator_html_gaa4146439d375f3a350a47a035ec247ed"><div class="ttname"><a href="group__Iterator.html#gaa4146439d375f3a350a47a035ec247ed">ltl::dereference</a></div><div class="ttdeci">auto dereference() noexcept</div><div class="ttdoc">dereference - returns a transform function that dereferrence objects</div><div class="ttdef"><b>Definition:</b> DefaultView.h:26</div></div>
<div class="ttc" id="agroup__Iterator_html_ga5fd743d82b92802a96c704cd9f871305"><div class="ttname"><a href="group__Iterator.html#ga5fd743d82b92802a96c704cd9f871305">ltl::map</a></div><div class="ttdeci">constexpr auto map(Fs... fs)</div><div class="ttdoc">map - Used to perform map operation on a functor</div><div class="ttdef"><b>Definition:</b> Map.h:100</div></div>
<div class="ttc" id="agroup__Utils_html_ga83843d907297b7a11d1875935371eb16"><div class="ttname"><a href="group__Utils.html#ga83843d907297b7a11d1875935371eb16">ltl::make_optional</a></div><div class="ttdeci">constexpr auto make_optional(T x)</div><div class="ttdoc">make_optional - build an optional</div><div class="ttdef"><b>Definition:</b> optional.h:248</div></div>
<div class="ttc" id="agroup__Actions_html_gad24b3915f4ed26cab9a1d90ad74e7813"><div class="ttname"><a href="group__Actions.html#gad24b3915f4ed26cab9a1d90ad74e7813">ltl::actions::sort</a></div><div class="ttdeci">constexpr Sort sort</div><div class="ttdoc">sort - action to sort an array</div><div class="ttdef"><b>Definition:</b> actions.h:68</div></div>
<div class="ttc" id="agroup__Actions_html_ga4df134e001b20a5dd3df25876b227c1c"><div class="ttname"><a href="group__Actions.html#ga4df134e001b20a5dd3df25876b227c1c">ltl::actions::sum</a></div><div class="ttdeci">constexpr Sum sum</div><div class="ttdoc">sum - Perform a sum</div><div class="ttdef"><b>Definition:</b> actions.h:377</div></div>
<div class="ttc" id="agroup__Iterator_html_ga0d78422df13a2d341e25918c79f81be3"><div class="ttname"><a href="group__Iterator.html#ga0d78422df13a2d341e25918c79f81be3">ltl::end_seq</a></div><div class="ttdeci">void end_seq()</div><div class="ttdoc">end_seq - Can be used to stop a generator function</div><div class="ttdef"><b>Definition:</b> seq.h:34</div></div>
<div class="ttc" id="agroup__Iterator_html_gade507d0b203461224cc0cdb92a6e1467"><div class="ttname"><a href="group__Iterator.html#gade507d0b203461224cc0cdb92a6e1467">ltl::seq</a></div><div class="ttdeci">auto seq(F f)</div><div class="ttdoc">seq - Transform a generator function into a lazy range</div><div class="ttdef"><b>Definition:</b> seq.h:50</div></div>
<div class="ttc" id="agroup__Predicate_html_ga5857312341913c48e744c1629662dea3"><div class="ttname"><a href="group__Predicate.html#ga5857312341913c48e744c1629662dea3">ltl::less_than</a></div><div class="ttdeci">constexpr auto less_than(T t)</div><div class="ttdoc">less_than- This function builds a predicate testing if a value is less than t</div><div class="ttdef"><b>Definition:</b> functional.h:390</div></div>
<div class="ttc" id="agroup__Iterator_html_ga54ef4e52db5c3f101bf95a9cdef15892"><div class="ttname"><a href="group__Iterator.html#ga54ef4e52db5c3f101bf95a9cdef15892">ltl::group_by</a></div><div class="ttdeci">auto group_by(F &amp;&amp;f)</div><div class="ttdoc">group_by - group elements of an array</div><div class="ttdef"><b>Definition:</b> Split.h:168</div></div>
<div class="ttc" id="agroup__Iterator_html_ga3ac37c2fa552273ee2d947f2930bb02d"><div class="ttname"><a href="group__Iterator.html#ga3ac37c2fa552273ee2d947f2930bb02d">ltl::ints</a></div><div class="ttdeci">auto ints()</div><div class="ttdoc">ints - returns an &quot;infinite&quot; list beginning at 0</div><div class="ttdef"><b>Definition:</b> Value.h:113</div></div>
<div class="ttc" id="agroup__Iterator_html_ga7b03e216561ecbfb53d050fe3c9960bc"><div class="ttname"><a href="group__Iterator.html#ga7b03e216561ecbfb53d050fe3c9960bc">ltl::split</a></div><div class="ttdeci">auto split(T t)</div><div class="ttdoc">split - Used to split an array according to an element</div><div class="ttdef"><b>Definition:</b> Split.h:113</div></div>
<div class="ttc" id="agroup__Iterator_html_gaa9a8eb5e6a506100aff4a16152809753"><div class="ttname"><a href="group__Iterator.html#gaa9a8eb5e6a506100aff4a16152809753">ltl::zip</a></div><div class="ttdeci">auto zip(Containers &amp;&amp;...containers)</div><div class="ttdoc">zip - Allows to iterate on several containers at the same time</div><div class="ttdef"><b>Definition:</b> Zip.h:91</div></div>
<div class="ttc" id="agroup__Actions_html_ga8024db6ac1061ac068776a861060389f"><div class="ttname"><a href="group__Actions.html#ga8024db6ac1061ac068776a861060389f">ltl::actions::unique</a></div><div class="ttdeci">constexpr Unique unique</div><div class="ttdoc">unique - action to remove adjacent duplicates</div><div class="ttdef"><b>Definition:</b> actions.h:129</div></div>
<div class="ttc" id="anamespaceltl_html"><div class="ttname"><a href="namespaceltl.html">ltl</a></div><div class="ttdoc">The LTL namespace.</div><div class="ttdef"><b>Definition:</b> algos.h:23</div></div>
<div class="ttc" id="agroup__Iterator_html_gacedb09b08c951309da418b9912d69c32"><div class="ttname"><a href="group__Iterator.html#gacedb09b08c951309da418b9912d69c32">ltl::reversed</a></div><div class="ttdeci">constexpr reverse_t reversed</div><div class="ttdoc">reversed - Used to iterate on a reversed array</div><div class="ttdef"><b>Definition:</b> Reverse.h:117</div></div>
<div class="ttc" id="agroup__Iterator_html_gaa6c8a1e5de898576082f39b3b81b180a"><div class="ttname"><a href="group__Iterator.html#gaa6c8a1e5de898576082f39b3b81b180a">ltl::chunks</a></div><div class="ttdeci">chunk_t chunks(std::size_t n)</div><div class="ttdoc">chunks - group elements by chunks of n elements</div><div class="ttdef"><b>Definition:</b> Split.h:137</div></div>
<div class="ttc" id="agroup__Iterator_html_ga822354d10fc9425934c42b624ee8b4f8"><div class="ttname"><a href="group__Iterator.html#ga822354d10fc9425934c42b624ee8b4f8">ltl::get</a></div><div class="ttdeci">auto get(number_t&lt; N &gt;)</div><div class="ttdoc">get - Generalization of ltl::keys and ltl::values for nth values</div><div class="ttdef"><b>Definition:</b> DefaultView.h:78</div></div>
<div class="ttc" id="agroup__Iterator_html_gab9354e42fded1cf717685d179f83dc68"><div class="ttname"><a href="group__Iterator.html#gab9354e42fded1cf717685d179f83dc68">ltl::to_pair</a></div><div class="ttdeci">auto to_pair</div><div class="ttdoc">to_pair - A transform function that transform a tuple of 2 elements into a pair</div><div class="ttdef"><b>Definition:</b> DefaultView.h:67</div></div>
<div class="ttc" id="agroup__Iterator_html_ga93e03390a20d5d3e15fa03ef6e75f000"><div class="ttname"><a href="group__Iterator.html#ga93e03390a20d5d3e15fa03ef6e75f000">ltl::join</a></div><div class="ttdeci">constexpr join_t join</div><div class="ttdoc">join join an array of array into one big array</div><div class="ttdef"><b>Definition:</b> Join.h:114</div></div>
<div class="ttc" id="agroup__Predicate_html_ga777694a4b96b1e382d095982de34a8e1"><div class="ttname"><a href="group__Predicate.html#ga777694a4b96b1e382d095982de34a8e1">ltl::not_</a></div><div class="ttdeci">constexpr auto not_(Fs... fs)</div><div class="ttdoc">This function negates its input.</div><div class="ttdef"><b>Definition:</b> functional.h:232</div></div>
<div class="ttc" id="agroup__Predicate_html_gac38720fc28032cf85803d4860c42cd09"><div class="ttname"><a href="group__Predicate.html#gac38720fc28032cf85803d4860c42cd09">ltl::equal_to</a></div><div class="ttdeci">constexpr auto equal_to(T t)</div><div class="ttdoc">equal_to- This function builds a predicate testing if a value is equal to t</div><div class="ttdef"><b>Definition:</b> functional.h:450</div></div>
<div class="ttc" id="agroup__Iterator_html_gaaa844a1d26bfc69422ea7c4aad338d22"><div class="ttname"><a href="group__Iterator.html#gaaa844a1d26bfc69422ea7c4aad338d22">ltl::valueRange</a></div><div class="ttdeci">auto valueRange()</div><div class="ttdoc">valueRange - returns the full range value of type ValueType</div><div class="ttdef"><b>Definition:</b> Value.h:61</div></div>
<div class="ttc" id="agroup__Function_html_ga9d966b78854a64163c1abe442260ef3d"><div class="ttname"><a href="group__Function.html#ga9d966b78854a64163c1abe442260ef3d">ltl::curry</a></div><div class="ttdeci">constexpr decltype(auto) curry(F f, Args &amp;&amp;...args)</div><div class="ttdoc">curry - Currying is done to transform n ary function into unary ones</div><div class="ttdef"><b>Definition:</b> functional.h:69</div></div>
<div class="ttc" id="agroup__Iterator_html_ga87828246d210b7f31c7fd30ca22fd84f"><div class="ttname"><a href="group__Iterator.html#ga87828246d210b7f31c7fd30ca22fd84f">ltl::drop_n</a></div><div class="ttdeci">auto drop_n(std::size_t n)</div><div class="ttdoc">drop_n - Remove the first n elements</div><div class="ttdef"><b>Definition:</b> Taker.h:105</div></div>
<div class="ttc" id="agroup__Iterator_html_ga71aaad82623b7b38009d52cde1a31323"><div class="ttname"><a href="group__Iterator.html#ga71aaad82623b7b38009d52cde1a31323">ltl::values</a></div><div class="ttdeci">auto values()</div><div class="ttdoc">keys - may be used to iterate on the values of one map</div><div class="ttdef"><b>Definition:</b> DefaultView.h:104</div></div>
<div class="ttc" id="agroup__Iterator_html_ga37704dc3acaccee28755709ef75ed354"><div class="ttname"><a href="group__Iterator.html#ga37704dc3acaccee28755709ef75ed354">ltl::take_n</a></div><div class="ttdeci">auto take_n(std::size_t n)</div><div class="ttdoc">take_n - take the first n elements</div><div class="ttdef"><b>Definition:</b> Taker.h:93</div></div>
<div class="ttc" id="agroup__Iterator_html_ga79fbf6f82cc0622866f1e704102690d3"><div class="ttname"><a href="group__Iterator.html#ga79fbf6f82cc0622866f1e704102690d3">ltl::make_repeater_range</a></div><div class="ttdeci">auto make_repeater_range(T value, long long int number) noexcept</div><div class="ttdoc">make_repeater_range - returns a range of number time value</div><div class="ttdef"><b>Definition:</b> Repeater.h:116</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
