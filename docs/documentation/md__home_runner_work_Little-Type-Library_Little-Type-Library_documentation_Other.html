<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Little Type Library: Other utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Little Type Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_Little-Type-Library_Little-Type-Library_documentation_Other.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Other utilities </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md27"></a>
Helper for conditions</h1>
<p>Available in <code><a class="el" href="condition_8h.html">ltl/condition.h</a></code> header file, you will find <code><a class="el" href="classltl_1_1AllOf.html" title="The AllOf condition helper.">ltl::AllOf</a></code>, <code><a class="el" href="classltl_1_1AnyOf.html" title="The AnyOf condition helper.">ltl::AnyOf</a></code> and <code><a class="el" href="classltl_1_1NoneOf.html" title="The NoneOf condition helper.">ltl::NoneOf</a></code></p>
<p>These helpers are easy to use:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> a = 8, b = 8, c = 8;</div>
<div class="line"> </div>
<div class="line">static_assert(AllOf{a, b, c} == 8);</div>
<div class="line">static_assert(AllOf{a, b, c} &lt;= 8);</div>
<div class="line">static_assert(AllOf{<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>});</div>
<div class="line">static_assert(AnyOf{<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>});</div>
</div><!-- fragment --><p>All of the operator are available: <code>&lt;, &lt;=, ==, !=, &gt;=, &gt;</code></p>
<h1><a class="anchor" id="autotoc_md28"></a>
Variant Helpers</h1>
<p>Available in <code><a class="el" href="VariantUtils_8h.html">ltl/VariantUtils.h</a></code> header file, you will find:</p>
<ul>
<li><code>is_callable_from(f, variant)</code>: Function that test if f can handle every types of the variant</li>
<li><code>match(variant, f...)</code>: Function that makes easier the use of several lambdas when trying to visit a variant</li>
<li><code>recursive_wrapper</code>: Helper for recursive variants</li>
<li><code>recursive_variant</code>: A true recursive variant:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test_variant_recursive() {</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespaceltl.html">ltl</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> Variant =</div>
<div class="line">      <a class="code" href="classltl_1_1recursive__variant.html">recursive_variant&lt;int, double, std::string, recursive_wrapper&lt;struct R&gt;</a>&gt;;</div>
<div class="line">  <span class="keyword">struct </span>R {</div>
<div class="line">    Variant v;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  Variant i = 5;</div>
<div class="line">  Variant d = 5.0;</div>
<div class="line">  Variant s = std::string{<span class="stringliteral">&quot;Test&quot;</span>};</div>
<div class="line">  Variant r = 0;</div>
<div class="line">  R firstR{8};</div>
<div class="line">  firstR.v = R{8};</div>
<div class="line">  r = std::move(firstR);</div>
<div class="line"> </div>
<div class="line">  recursive_visit(<a class="code" href="structltl_1_1overloader.html">overloader</a>{[](<span class="keyword">auto</span> &amp;&amp;) { assert(<span class="keyword">false</span>); }, [](int) {}}, i);</div>
<div class="line">  recursive_visit(<a class="code" href="structltl_1_1overloader.html">overloader</a>{[](<span class="keyword">auto</span> &amp;&amp;) { assert(<span class="keyword">false</span>); }, [](double) {}}, d);</div>
<div class="line">  recursive_visit(</div>
<div class="line">      <a class="code" href="structltl_1_1overloader.html">overloader</a>{[](<span class="keyword">auto</span> &amp;&amp;) { assert(<span class="keyword">false</span>); }, [](std::string) {}}, s);</div>
<div class="line">  recursive_visit(<a class="code" href="structltl_1_1overloader.html">overloader</a>{[](<span class="keyword">auto</span> &amp;&amp;) { assert(<span class="keyword">false</span>); },</div>
<div class="line">                             [](R &amp;r) {</div>
<div class="line">                               recursive_visit(</div>
<div class="line">                                   <a class="code" href="structltl_1_1overloader.html">overloader</a>{[](<span class="keyword">auto</span> &amp;&amp;) { assert(<span class="keyword">false</span>); },</div>
<div class="line">                                              [](R &amp;r) {</div>
<div class="line">                                                recursive_visit(</div>
<div class="line">                                                    <a class="code" href="structltl_1_1overloader.html">overloader</a>{[](<span class="keyword">auto</span> &amp;&amp;) {</div>
<div class="line">                                                                 assert(<span class="keyword">false</span>);</div>
<div class="line">                                                               },</div>
<div class="line">                                                               [](int) {}},</div>
<div class="line">                                                    r.v);</div>
<div class="line">                                              }},</div>
<div class="line">                                   r.v);</div>
<div class="line">                             }},</div>
<div class="line">                  r);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29"></a>
Strong types</h1>
<p>If you have never heard about strong types, you better go to see <a href="http://fluentcpp.com">Jonathan Boccara's blog</a> before reading the following section. Actually, I was inspired a lot by his articles about strong typing. For people who do not want to read everything, here is a little summary.</p>
<p>Let's say you want to develop a GUI application. You want to create a window with a width of 800, and a height of 600. You will probably write something like: <code>Window myWindow{800, 600};</code>. However, how do you know if you are using <code>800</code> for the width and not for the height? <code>strong_type</code>s solves this first problem. Now you will write something like : <code>Window myWindow{Width{800}, Height{600}};</code>. Now there is no shadow of a doubt, and, obviously, you can not convert a <code>Width</code> into a <code>Height</code>. We add a kind of <em>type-safety</em> into our code.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
How to declare a strong type in LTL</h2>
<p>There is a type : <code>strong_type_t&lt;T, Tag, Skills...&gt;</code> in the <code>namespace ltl</code>. You can declare, for example, our prior <code>Width</code> and <code>Height</code> types as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Width = <a class="code" href="classltl_1_1detail_1_1strong__type__t.html">ltl::strong_type_t&lt;float, struct WidthTag&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> Height = <a class="code" href="classltl_1_1detail_1_1strong__type__t.html">ltl::strong_type_t&lt;float, struct HeightTag&gt;</a>;</div>
</div><!-- fragment --><p>You can get the value using the <code>get</code> function: </p><div class="fragment"><div class="line">Width width{5.0f};</div>
<div class="line">std::cout &lt;&lt; width.get() &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Add operation to strong types</h2>
<p>We saw that <code>strong_type_t</code>takes <code>Skills...</code> template parameters. But how to use them? As of now, Little Type Library has several skills available:</p>
<ul>
<li>Arithmetic ones:<ul>
<li><code>Addable</code> : <code>operator +</code></li>
<li><code>Subtractable</code> : <code>operator -</code></li>
<li><code>Multipliable</code> : <code>operator *</code></li>
<li><code>Dividable</code> : <code>operator /</code></li>
<li><code>Moduloable</code> : <code>operator %</code></li>
<li><code>Incrementable</code> : <code>operator++</code></li>
<li><code>Decrementable</code>: <code>operator--</code></li>
</ul>
</li>
<li>Comparison ones:<ul>
<li><code>GreatherThan</code> : <code>operator &gt;</code></li>
<li><code>LessThan</code> : <code>operator &lt;</code></li>
<li><code>GreatherThanEqual</code> : <code>operator &gt;=</code></li>
<li><code>LessThanEqual</code> : <code>operator &lt;=</code></li>
<li><code>EqualityComparable</code> : <code>operator==</code> and <code>operator!=</code></li>
<li><code>AllComparable</code> : All of the above</li>
</ul>
</li>
<li>Stream ones:<ul>
<li><code>OStreamable</code> : <code>operator &lt;&lt;(std::ostream&amp;)</code></li>
</ul>
</li>
</ul>
<p>You can do as follows with one or several skills above or your own skills: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Float = <a class="code" href="classltl_1_1detail_1_1strong__type__t.html">ltl::strong_type_t&lt;float, struct FloatTag, ltl::OStreamable&gt;</a>;</div>
<div class="line">Float f{8.0f};</div>
<div class="line">std::cout &lt;&lt; f &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Write your own skills</h2>
<p>Let's say you want to write a skill <code>Printable</code> that adds the function <code>print()</code> to the <code>strong_type</code>. There are two ways. The first one is to use CRTP, the second one is not to use CRTP. Basically, you need CRTP to add member functions, and you do not need it to add <code>friend</code> functions. We will only see how to use CRTP because it is harder than not to use it.</p>
<p>There is a little helper <code>class crtp</code> in the <code>namespace ltl</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TheStrongType&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable : ltl::crtp&lt;TheStrongType, Printable&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> print()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">/* this-&gt;underlying is a crtp member function that</span></div>
<div class="line"><span class="comment">           basically means static_cast&lt;TheStrongType&amp;&gt;(*this) */</span></div>
<div class="line">        std::cout &lt;&lt; this-&gt;underlying().get() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Done !</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Convert a meter to a kilometer</h2>
<p>Let's say you have a type <code>Meter</code>. However, you want <code>Meter</code> to be convertible to <code>Kilometer</code>. We can define <code>Kilometer</code> as a multiple of <code>Meter</code>:</p>
<div class="fragment"><div class="line">using Meter = ltl::strong_type_t&lt;float, struct DistanceTag&gt;;</div>
<div class="line">using Kilometer = ltl::multiple_of&lt;Meter, std::ratio&lt;1000&gt;&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Write your own converter</h2>
<p>Imagine you want to convert radians to degrees, or Watts to decibels. It is not a simple ratio, and it is not integer values. The idea is to write your own convert functions!</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ConverterRadianDegree {</div>
<div class="line">  [[nodiscard]] <span class="keyword">static</span> constexpr <span class="keywordtype">float</span> convertToReference(<span class="keywordtype">float</span> degree) {</div>
<div class="line">    <span class="keywordflow">return</span> degree * pi / 180.0f;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">static</span> constexpr <span class="keywordtype">float</span> convertFromReference(<span class="keywordtype">float</span> radians) {</div>
<div class="line">    <span class="keywordflow">return</span> radians * 180.0f / pi;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> radians =</div>
<div class="line">    <a class="code" href="classltl_1_1detail_1_1strong__type__t.html">ltl::strong_type_t&lt;float, struct AngleTag, ltl::EqualityComparable&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> degrees = ltl::add_converter&lt;radians, ConverterRadianDegree&gt;;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md35"></a>
Streambuf</h1>
<p>In <code><a class="el" href="stream_8h.html">ltl/stream.h</a></code>, you will find two <code>streambuf</code> class to write or read from an array.</p>
<ul>
<li><code><a class="el" href="classltl_1_1basic__readonly__streambuf.html">ltl::basic_readonly_streambuf</a></code></li>
<li><code><a class="el" href="classltl_1_1basic__writeonly__streambuf.html">ltl::basic_writeonly_streambuf</a></code> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceltl_html"><div class="ttname"><a href="namespaceltl.html">ltl</a></div><div class="ttdoc">The LTL namespace.</div><div class="ttdef"><b>Definition:</b> algos.h:23</div></div>
<div class="ttc" id="aclassltl_1_1recursive__variant_html"><div class="ttname"><a href="classltl_1_1recursive__variant.html">ltl::recursive_variant</a></div><div class="ttdoc">The recursive_variant class - A variant that supports recursive type.</div><div class="ttdef"><b>Definition:</b> VariantUtils.h:90</div></div>
<div class="ttc" id="aclassltl_1_1detail_1_1strong__type__t_html"><div class="ttname"><a href="classltl_1_1detail_1_1strong__type__t.html">ltl::detail::strong_type_t</a></div><div class="ttdef"><b>Definition:</b> StrongType.h:27</div></div>
<div class="ttc" id="astructltl_1_1overloader_html"><div class="ttname"><a href="structltl_1_1overloader.html">ltl::overloader</a></div><div class="ttdef"><b>Definition:</b> ltl.h:57</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
